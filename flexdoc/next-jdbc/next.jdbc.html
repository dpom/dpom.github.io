<!DOCTYPE html PUBLIC "" "">
<html>
<head>
  <meta charset="UTF-8" />
  <title>next-jdbc</title>
  <link rel="stylesheet" type="text/css" href="https://dpom.github.io/flexdoc/css/default.css" />
  <link rel="stylesheet" type="text/css" href="https://dpom.github.io/flexdoc/css/highlight.css" />
  <script type="text/javascript" src="https://dpom.github.io/flexdoc/js/highlight.min.js"></script>
  <script type="text/javascript" src="https://dpom.github.io/flexdoc/js/jquery.min.js"></script>
  <script type="text/javascript" src="https://dpom.github.io/flexdoc/js/page_effects.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="header">
    <h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2>
    <h1><a href="https://dpom.github.io/flexdoc/next-jdbc/index.html">
        <span class="project-title">
          <span class="project-name">next-jdbc</span>
          <span class="project-version"></span>
        </span>
      </a>
    </h1>
  </div>
  <div id="sidebar1" class="sidebar primary">
  <h3 class="no-link">
    <span class="inner">Project</span>
  </h3>
  <ul class="index-link">
     <li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>next</span></div></div></li><li class="depth-2"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.datafy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datafy</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.date-time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>date-time</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.optional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>optional</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.plan.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plan</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.prepare.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prepare</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.quoted.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quoted</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.result-set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>result-set</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-3"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.sql.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sql</span></div></a></li><li class="depth-4"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.sql.builder.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builder</span></div></a></li><li class="depth-3 branch"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.transaction.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>transaction</span></div></a></li><li class="depth-3"><a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li> 
  </ul>
  </div>
  
<div id="sidebar2" class="sidebar secondary">
  <h3>
    <a href="#top">
      <span class="inner">Public Vars</span>
    </a>
  </h3>
  <ul id="pubvarmenu">
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/execute!.html">
        <span>execute!</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/execute-batch!.html">
        <span>execute-batch!</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/execute-one!.html">
        <span>execute-one!</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/get-connection.html">
        <span>get-connection</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/get-datasource.html">
        <span>get-datasource</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/on-connection.html">
        <span>on-connection</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/plan.html">
        <span>plan</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/prepare.html">
        <span>prepare</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/snake-kebab-opts.html">
        <span>snake-kebab-opts</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/transact.html">
        <span>transact</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/unqualified-snake-kebab-opts.html">
        <span>unqualified-snake-kebab-opts</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/with-logging.html">
        <span>with-logging</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/with-options.html">
        <span>with-options</span>
      </a>
    </li>
    
    <li id="pubvaritem" class="depth-1">
      <a href="https://dpom.github.io/flexdoc/next-jdbc/next.jdbc/with-transaction.html">
        <span>with-transaction</span>
      </a>
    </li>
    
  </ul>
</div>

<div id="content" class="namespaces-docs">
  <table id="pubvar-list">
    <tr>
      <th>Public Var</th>
      <th>Description</th>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">execute!</td>
      <td class="pubvar-doc">General SQL execution function.

Returns a fully-realized result set. When `:multi-rs true` is provided, will
return multiple result sets, as a vector of result sets. Each result set is
a vector of hash maps, by default, but can be controlled by the `:builder-fn`
option.

Can be called on a `PreparedStatement`, a `Connection`, or something that can
produce a `Connection` via a `DataSource`.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">execute-batch!</td>
      <td class="pubvar-doc">Given a `PreparedStatement` and a vector containing parameter groups,
i.e., a vector of vector of parameters, use `.addBatch` to add each group
of parameters to the prepared statement (via `set-parameters`) and then
call `.executeBatch`. A vector of update counts is returned.

An options hash map may also be provided, containing `:batch-size` which
determines how to partition the parameter groups for submission to the
database. If omitted, all groups will be submitted as a single command.
If you expect the update counts to be larger than `Integer/MAX_VALUE`,
you can specify `:large true` and `.executeLargeBatch` will be called
instead.

Alternatively, given a connectable, a SQL string, a vector containing
parameter groups, and an options hash map, create a new `PreparedStatement`
(after possibly creating a new `Connection`), and execute the SQL with
the specified parameter groups. That new `PreparedStatement` (and the
new `Connection`, if created) will be closed automatically after use.

By default, returns a Clojure vector of update counts. Some databases
allow batch statements to also return generated keys and you can attempt that
if you ensure the `PreparedStatement` is created with `:return-keys true`
and you also provide `:return-generated-keys true` in the options passed
to `execute-batch!`. Some databases will only return one generated key
per batch, some return all the generated keys, some will throw an exception.
If that is supported, `execute-batch!` will return a vector of hash maps
containing the generated keys as fully-realized, datafiable result sets,
whose content is database-dependent.

May throw `java.sql.BatchUpdateException` if any part of the batch fails.
You may be able to call `.getUpdateCounts` on that exception object to
get more information about which parts succeeded and which failed.

For additional caveats and database-specific options you may need, see:
https://cljdoc.org/d/com.github.seancorfield/next.jdbc/CURRENT/doc/getting-started/prepared-statements#caveats

Not all databases support batch execution.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">execute-one!</td>
      <td class="pubvar-doc">General SQL execution function that returns just the first row of a result.
For any DDL or SQL statement that will return just an update count, this is
the preferred function to use.

Can be called on a `PreparedStatement`, a `Connection`, or something that can
produce a `Connection` via a `DataSource`.

Note: although this only returns the first row of a result set, it does not
place any limit on the result of the SQL executed.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">get-connection</td>
      <td class="pubvar-doc">Given some sort of specification of a database, return a new `Connection`.

  In general, this should be used via `with-open`:

```clojure
  (with-open [con (get-connection spec opts)]
    (run-some-ops con))
```

  If you call `get-connection` on a `DataSource`, it just calls `.getConnection`
  and applies the `:auto-commit` and/or `:read-only` options, if provided.

  If you call `get-connection` on anything else, it will call `get-datasource`
  first to try to get a `DataSource`, and then call `get-connection` on that.

  If you want different per-connection username/password values, you can
  either put `:user` and `:password` into the `opts` hash map or pass them
  as positional arguments.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">get-datasource</td>
      <td class="pubvar-doc">Given some sort of specification of a database, return a `DataSource`.

A specification can be a JDBC URL string (which is passed to the JDBC
driver as-is), or a hash map.

For the hash map, there are two formats accepted:

In the first format, these keys are required:
* `:dbtype` -- a string indicating the type of the database
* `:dbname` -- a string indicating the name of the database to be used

The following optional keys are commonly used:
* `:user` -- the username to authenticate with
* `:password` -- the password to authenticate with
* `:host` -- the hostname or IP address of the database (default: `127.0.0.1`);
    can be `:none` which means the host/port segment of the JDBC URL should
    be omitted entirely (for &#39;local&#39; databases)
* `:port` -- the port for the database connection (the default is database-
    specific -- see below)
* `:classname` -- if you need to override the default for the `:dbtype`
    (or you want to use a database that next.jdbc does not know about!)

The following optional keys can be used to control how JDBC URLs are
assembled. This may be needed for `:dbtype` values that `next.jdbc`
does not recognize:
* `:dbname-separator` -- override the `/` or `:` that normally precedes
    the database name in the JDBC URL
* `:host-prefix` -- override the `//` that normally precedes the IP
    address or hostname in the JDBC URL
* `:property-separator` -- an optional string that can be used to override
    the separators used in `jdbc-url` for the properties (after the initial
    JDBC URL portion); by default `?` and `&amp;` are used to build JDBC URLs
    with properties; for SQL Server drivers (both MS and jTDS)
    `:property-separator &quot;;&quot;` is used

In the second format, this key is required:
* `:jdbcUrl` -- a JDBC URL string

Any additional options provided will be passed to the JDBC driver&#39;s
`.getConnection` call as a `java.util.Properties` structure.

Database types supported (for `:dbtype`), and their defaults:
* `derby` -- `org.apache.derby.jdbc.EmbeddedDriver` -- also pass `:create true`
    if you want the database to be automatically created
* `duckdb` -- `org.duckdb.DuckDBDriver` -- embedded database
* `h2` -- `org.h2.Driver` -- for an on-disk database
* `h2:mem` -- `org.h2.Driver` -- for an in-memory database
* `hsqldb`, `hsql` -- `org.hsqldb.jdbcDriver`
* `jtds:sqlserver`, `jtds` -- `net.sourceforge.jtds.jdbc.Driver` -- `1433`
* `mariadb` -- `org.mariadb.jdbc.Driver` -- `3306`
* `mysql` -- `com.mysql.cj.jdbc.Driver`, `com.mysql.jdbc.Driver` -- `3306`
* `oracle:oci` -- `oracle.jdbc.OracleDriver` -- `1521`
* `oracle:thin`, `oracle` -- `oracle.jdbc.OracleDriver` -- `1521`
* `oracle:sid` -- `oracle.jdbc.OracleDriver` -- `1521` -- uses the legacy `:`
    separator for the database name but otherwise behaves like `oracle:thin`
* `postgresql`, `postgres` -- `org.postgresql.Driver` -- `5432`
* `pgsql` -- `com.impossibl.postgres.jdbc.PGDriver` -- no default port
* `redshift` -- `com.amazon.redshift.jdbc.Driver` -- no default port
* `sqlite` -- `org.sqlite.JDBC`
* `sqlserver`, `mssql` -- `com.microsoft.sqlserver.jdbc.SQLServerDriver` -- `1433`
* `timesten:client` -- `com.timesten.jdbc.TimesTenClientDriver`
* `timesten:direct` -- `com.timesten.jdbc.TimesTenDriver`

For more details about `:dbtype` and `:classname` values, see:
https://cljdoc.org/d/com.github.seancorfield/next.jdbc/CURRENT/api/next.jdbc.connection#dbtypes</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">on-connection</td>
      <td class="pubvar-doc">Given a connectable object, gets a connection and binds it to `sym`,
  then executes the `body` in that context.

  This allows you to write generic, `Connection`-based code without
  needing to know the exact type of an incoming datasource:

```clojure
  (on-connection [conn datasource]
    (let [metadata (.getMetadata conn)
          catalog  (.getCatalog conn)]
      ...))
```

  If passed a `Connection` or a `Connectable` that wraps a `Connection`,
  then that `Connection` is used as-is.

  Otherwise, creates a new `Connection` object from the connectable,
  executes the body, and automatically closes it for you.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">plan</td>
      <td class="pubvar-doc">General SQL execution function (for working with result sets).

Returns a reducible that, when reduced, runs the SQL and yields the result.
The reducible is also foldable (in the `clojure.core.reducers` sense) but
see the **Tips &amp; Tricks** section of the documentation for some important
caveats about that.

Can be called on a `PreparedStatement`, a `Connection`, or something that can
produce a `Connection` via a `DataSource`.

Your reducing function can read columns by name (string or simple keyword)
from each row of the underlying `ResultSet` without realizing the row as
a Clojure hash map. `select-keys` can also be used without realizing the row.
Operations that imply an actual Clojure data structure (such as `assoc`,
`dissoc`, `seq`, `keys`, `vals`, etc) will realize the row into a hash map
using the supplied `:builder-fn` (or `as-maps` by default).

If your reducing function needs to produce a hash map without calling a
function that implicitly realizes the row, you can call:

`(next.jdbc.result-set/datafiable-row row connectable opts)`

passing in the current row (passed to the reducing function), a `connectable`,
and an `opts` hash map. These can be the same values that you passed to `plan`
(or they can be different, depending on how you want the row to be built,
and how you want any subsequent lazy navigation to be handled).</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">prepare</td>
      <td class="pubvar-doc">Given a connection to a database, and a vector containing SQL and any
  parameters it needs, return a new `PreparedStatement`.

  In general, this should be used via `with-open`:

```clojure
  (with-open [stmt (prepare spec sql-params opts)]
    (run-some-ops stmt))
```

  See the list of options above (in the namespace docstring) for what can
  be passed to prepare.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">snake-kebab-opts</td>
      <td class="pubvar-doc">A hash map of options that will convert Clojure identifiers to
snake_case SQL entities (`:table-fn`, `:column-fn`), and will convert
SQL entities to qualified kebab-case Clojure identifiers (`:builder-fn`).</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">transact</td>
      <td class="pubvar-doc">Given a transactable object and a function (taking a `Connection`),
execute the function over the connection in a transactional manner.

See `with-transaction` for supported options.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">unqualified-snake-kebab-opts</td>
      <td class="pubvar-doc">A hash map of options that will convert Clojure identifiers to
snake_case SQL entities (`:table-fn`, `:column-fn`), and will convert
SQL entities to unqualified kebab-case Clojure identifiers (`:builder-fn`).</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">with-logging</td>
      <td class="pubvar-doc">Given a connectable/transactable object and a sql/params logging
function and an optional result logging function that should be used
on all operations on that object, return a new wrapper object that can
be used in its place.

The sql/params logging function will be called with two arguments:
* a symbol indicating which operation is being performed:
  * `next.jdbc/plan`, `next.jdbc/execute-one!`, `next.jdbc/execute!`,
    or `next.jdbc/prepare`
* the vector containing the SQL string and its parameters
Whatever the sql/params logging function returns will be passed as a
`state` argument to the optional result logging function.

The result logging function, if provided, will be called with the
same symbol passed to the sql/params logging function, the `state`
returned by the sql/params logging function, and either the result of
the `execute!` or `execute-one!` call or an exception if the call
failed. The result logging function is not called for the `plan`
or `prepare` call (since they do not produce result sets directly).

Bear in mind that `get-datasource`, `get-connection`, and `with-transaction`
return plain Java objects, so if you call any of those on this wrapped
object, you&#39;ll need to re-wrap the Java object `with-logging` again. See
the Datasources, Connections &amp; Transactions section of Getting Started for
more details, and some examples of use with these functions.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">with-options</td>
      <td class="pubvar-doc">Given a connectable/transactable object and a set of (default) options
that should be used on all operations on that object, return a new
wrapper object that can be used in its place.

Bear in mind that `get-datasource`, `get-connection`, and `with-transaction`
return plain Java objects, so if you call any of those on this wrapped
object, you&#39;ll need to re-wrap the Java object `with-options` again. See
the Datasources, Connections &amp; Transactions section of Getting Started for
more details, and some examples of use with these functions.</td>
    </tr>
    
    <tr class="pubvar-item">
      <td class="pubvar-name">with-transaction</td>
      <td class="pubvar-doc">Given a transactable object, gets a connection and binds it to `sym`,
then executes the `body` in that context, committing any changes if the body
completes successfully, otherwise rolling back any changes made.

Like `with-open`, if `with-transaction` creates a new `Connection` object,
it will automatically close it for you.

The options map supports:
* `:isolation` -- `:none`, `:read-committed`, `:read-uncommitted`,
    `:repeatable-read`, `:serializable`,
* `:read-only` -- `true` / `false` (`true` will make the `Connection` readonly),
* `:rollback-only` -- `true` / `false` (`true` will make the transaction
    rollback, even if it would otherwise succeed).</td>
    </tr>
    
  </table>

</div>

</body>
